import flash.events.Event;import flash.display.BitmapData;import flash.display.Bitmap;import flash.filters.BitmapFilter;import flash.filters.BitmapFilterQuality;import flash.filters.GlowFilter;import flash.filters.BlurFilter;import flash.events.MouseEvent;var rows:uint = 0;var rule:uint = 30;var randomize:Boolean = true;var loop:Boolean = true;var bgColor:uint = 0x161616;var cellColor:uint = 0x17eb0a;var colorSheet:Object = {"0":bgColor, "1":cellColor};var ruleTable:Object;var worldSize:int = 200;var worldIndex:int = 0;var worldData:BitmapData = createWorld(worldSize, worldSize);var world:Bitmap;initWorld("1");initWorldGraphics();setRules(rule);addEventListener(Event.ENTER_FRAME, updateSimulation);initGUI();function createWorld(w:int, h:int):BitmapData {	var bd:BitmapData = new BitmapData(w, h, false, bgColor);	return bd;}function initWorld(init:String):void {	var startIndex:int = Math.floor((worldSize - init.length)/2);	for(var i:int = startIndex, j = 0; i < startIndex+init.length; i++, j++){		if(init.charAt(j) == "1"){			worldData.setPixel(i, worldIndex, cellColor);		} else {			worldData.setPixel(i, worldIndex, bgColor);		}	}}function initWorldGraphics():void {	world = new Bitmap(worldData);	world.x = 0;	world.y = 0;	world.scaleX = world.scaleY = 4;	addChild(world);	addEffects();}function clearWorld():void {	for(var i:int = 0; i < worldSize; i++){		for(var j:int = 0; j < worldSize; j++){			worldData.setPixel(j, i, bgColor);		}	}}function setRules(newRule:uint):void {	rule = newRule;	ruleTable = createRuleTable(rule);}function updateSimulation(e:Event):void {	if(rows > 0 || loop){		processAutomata();		rows--;	}	fadeWorld();}function processAutomata():void {	var lastIndex:int = worldIndex;	worldIndex++;	if(worldIndex >= worldSize){		worldIndex = 0;		if(randomize){			setRules(Math.floor(Math.random()*255));			initWorld(randomBinary(worldSize));			worldIndex = 1			lastIndex = 0;		}	} 		for(var i:int = 0; i < worldSize; i++){		var neighbors:String = getNeighbors(i, lastIndex);		var newState:String = ruleTable[neighbors];		worldData.setPixel(i, worldIndex, colorSheet[newState]);	}}function getNeighbors(cx:int, cy:int):String {	var center:String = pixelToBinary(cx, cy);	var lx:int = cx-1 >= 0?cx-1:worldSize-1;	var left:String = pixelToBinary(lx, cy);	var rx:int = cx+1 < worldSize?cx+1:0;	var right:String = pixelToBinary(rx, cy);	return left+center+right;}function pixelToBinary(cx:int, cy:int):String {	return worldData.getPixel(cx, cy)==cellColor?"1":"0";}function createRuleTable(theRule:uint):Object {	var ruleStr:String = decimalToBinary(theRule, 8);	var ruleObj:Object = new Object();	for(var i:int = 0; i < 8; i++){		ruleObj[decimalToBinary(i, 3)] = ruleStr.charAt(7-i);	}	return ruleObj;}function decimalToBinary(dec:uint, len:uint):String {	var bin:String = "";	while(dec > 0){		if(dec%2){			bin = "1" + bin;		} else {			bin = "0" + bin;		}		dec = Math.floor(dec/2);	}	while(bin.length < len){		bin = "0" + bin;	}	return bin;}function fadeWorld():void {	for(var i:int = 0; i < worldSize; i++){		if(i != worldIndex){			for(var j:int = 0; j < worldSize; j++){				var col:uint = worldData.getPixel(j, i);				col = blendColor(col, bgColor, 0.01);				worldData.setPixel(j, i, col);			}		}	}}function blendColor(c1:uint, c2:uint, percent:Number):uint {	var r:int = ((c1 & 0xff0000) >> 16) * (1 - percent) + ((c2 & 0xff0000) >> 16) * percent;	var g:int = ((c1 & 0x00ff00) >>  8) * (1 - percent) + ((c2 & 0x00ff00) >>  8) * percent;	var b:int = ((c1 & 0x0000ff)      ) * (1 - percent) + ((c2 & 0x0000ff)      ) * percent;	return r << 16 | g << 8 | b;}function addEffects():void {	var blur:BitmapFilter = new BlurFilter(5, 5, BitmapFilterQuality.MEDIUM);	world.filters = [blur];}function randomBinary(size:int):String {	var bin:String = "";	while(bin.length < size){		bin += Math.random()<0.5?"0":"1";	}	return bin;}function initGUI():void {	runBtn.addEventListener(MouseEvent.CLICK, resetSimulation);}function resetSimulation(e:MouseEvent = null):void {	clearWorld();	worldIndex = 0;	initWorld(String(stateTxt.text));	setRules(uint(ruleTxt.text));	rows = uint(stepTxt.text);	if(rows == 0){		loop = true;	} else {		loop = false;	}}